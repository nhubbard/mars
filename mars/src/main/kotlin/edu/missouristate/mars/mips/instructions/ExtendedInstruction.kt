/*
 * Copyright (c) 2003-2024, Pete Sanderson and Kenneth Vollmar
 * Copyright (c) 2024-present, Nicholas Hubbard
 *
 * Created by Pete Sanderson (psanderson@otterbein.edu) and Kenneth Vollmar (kenvollmar@missouristate.edu)
 * Maintained by Nicholas Hubbard (nhubbard@users.noreply.github.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 *    the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Copyright (c) 2017-2024, Niklas Persson
 * Copyright (c) 2024-present, Nicholas Hubbard
 *
 * The IntelliJ plugin is licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for specific
 * language governing permissions and limitations under the License.
 */

@file:Suppress("MemberVisibilityCanBePrivate")

package edu.missouristate.mars.mips.instructions

import edu.missouristate.mars.Globals
import edu.missouristate.mars.MIPSProgram
import edu.missouristate.mars.CoreSettings
import edu.missouristate.mars.assembler.TokenList
import edu.missouristate.mars.mips.hardware.RegisterFile
import edu.missouristate.mars.signExtend
import edu.missouristate.mars.util.Binary.bitValue
import edu.missouristate.mars.util.Binary.stringToInt

/**
 * Constructor for ExtendedInstruction.
 *
 * @param exampleFormat      A String containing example use of the MIPS extended instruction.
 * @param translation        Specifications for translating this instruction into a sequence
 *                           of one or more MIPS basic instructions.
 * @param compactTranslation Alternative translation that can be used if running under
 *                           a compact (16 bit) memory configuration.
 *                           Null if not provided.
 * @param description        A helpful description to be included on help requests.
 *                           Empty if not provided.
 *
 * The presence of an alternative "compact translation" can optimize code generation
 * by assuming that data label addresses are 16 bits instead of 32.
 */
class ExtendedInstruction @JvmOverloads constructor(
    override var exampleFormat: String,
    val translation: String,
    val compactTranslation: String? = null,
    override var description: String = ""
) : Instruction() {
    override var name: String = extractOperator(exampleFormat)

    private val translationStrings: ArrayList<String>
    private val compactTranslationStrings: ArrayList<String>?

    init {
        createExampleTokenList()
        translationStrings = buildTranslationList(translation)!!
        compactTranslationStrings = compactTranslation?.let { buildTranslationList(it) }
    }

    /**
     * Get the length in bytes that this extended instruction requires in its binary form.
     * The answer depends on how many basic instructions it expands to.
     * This may vary if expansion includes a nop, depending on whether delayed branching is enabled.
     * Each instruction requires four bytes.
     */
    override val instructionLength: Int = getInstructionLength(translationStrings)

    /**
     * Get the list of templates for basic instructions generated by this extended instruction.
     */
    val basicInstructionTemplateList: ArrayList<String> get() = translationStrings

    /**
     * Get the length in bytes that this extended instruction requires in its binary form if it includes an alternative
     * expansion for compact memory (16-bit addressing) configurations.
     * The answer depends on how many basic instructions this extended instruction translates to.
     * This may vary if expansion includes a nop, depending on whether delayed branching is enabled.
     * Each basic instruction requires four bytes.
     */
    val compactInstructionLength: Int get() = getInstructionLength(compactTranslationStrings)

    /**
     * Determine whether this extended instruction has a compact translation for 16-bit addressing.
     */
    val hasCompactTranslation: Boolean get() = compactTranslationStrings != null

    /**
     * Get the list of templates for basic instructions generated by the compact version of this extended instruction.
     * Returns null if the instruction does not have a compact translation.
     */
    val compactBasicInstructionTemplateList: ArrayList<String>? get() = compactTranslationStrings

    companion object {
        /**
         * Given a basic instruction template and the list of tokens from an extended instruction statement, substitute
         * operands from the token list appropriately into the template to generate the basic statement.
         * Assumes the extended instruction statement has been translated from source form to its basic assembly form
         * (e.g., register mnemonics translated to corresponding register numbers).
         * The operand format of the source statement is already verified correct.
         * Assume the template has the correct number and positions of operands.
         * The template is a String with special markers.
         * In the list below, n represents token position (1, 2, 3, etc.) in the source statement, where the operator is
         * token 0, and parentheses count, but commas don't count.
         * If `m` appears in the template, it is always 1, 2, 3, or 4.
         *
         * - `RGn`: substitute register found in `n`th token of the source statement.
         * - `NRn`: substitute next higher register than the one in `n`th token of source code.
         * - `OPn`: substitute `n`th token of source code as-is.
         * - `LLn`: substitute the low-order 16 bits from the label address in source token `n`.
         * - `LLnU`: substitute the unsigned low-order 16 bits from the label address in source token `n`.
         * - `LLnPm`: substitute the low-order 16 bits from the label address in source token `n`, after adding `m`.
         * - `LHn`: substitute the high-order 16 bits from the label address in source token `n`. It must add 1 if the
         *   address bit (15) is set to 1.
         * - `LHnPm`: substitute the high-order 16 bits from the label address in source token `n`, after adding `m`.
         *   It must then add 1 if the address bit (15) is 1.
         * - `VLn`: substitute the low-order 16 bits from the 32-bit value in source token `n`.
         * - `VLnU`: substitute the unsigned low-order 16 bits from the 32-bit value in source token `n`.
         * - `VLnPm`: substitute the low-order 16 bits from the 32-bit value in source token `n`, after adding `m` to
         *   the value.
         * - `VLnPmU`: substitute the unsigned low-order 16 bits from the 32-bit value in source token `n`, after
         *   adding `m` to value.
         * - `VHLn`: substitute the high-order 16 bits from the 32-bit value in source token `n`. Use this if later
         *   combined with low-order 16 bits using `ori $1,$1,VLn`. See logical and branch operations.
         * - `VHn`: substitute the high-order 16 bits from the 32-bit value in source token `n`, then add 1 if the
         *   value's address bit (15) is 1. Use this only if the later instruction uses `VLn($1)` to calculate a 32-bit
         *   address. See loads and stores.
         * - `VHLnPm`: substitute the high-order 16 bits from the 32-bit value in source token `n`, after adding `m`.
         *   See `VHLn`.
         * - `VHnPm`: substitute the high-order 16 bits from the 32-bit value in source token `n`, after adding `m`;
         *   then adds 1 if the address bit (15) is 1. See `VHn`.
         * - `LLP`: similar to `LLn`, but for calculating the `label+100000` address offset. The immediate value is
         *   added before taking the low-order 16 bits.
         * - `LLPU`: similar to `LLnU`, but for calculating the `label+100000` address offset. The immediate value is
         *   added before taking the unsigned low-order 16 bits.
         * - `LLPPm`: similar to `LLP`, except `m` is added to the immediate value before taking the low-order 16 bits.
         * - `LHPA`: similar to `LHn`, but for calculating the `label+100000` address offset. The immediate value is
         *   added before taking the high-order 16 bits.
         * - `LHPN`: similar to `LHPA`, but only used by the `la` instruction. The address is resolved by `ori`, so
         *   don't add 1 if the address bit (15) is 1.
         * - `LHPAPm`: similar to `LHPA`, except the value of `m` is added along with the immediate value before taking
         *   the high-order 16 bits.
         * - `LHL`: substitute the high-order 16 bits from the label address in token 2 of the `la` source statement.
         * - `LAB`: substitute the textual label from the last token of the source statement. Used for various branches.
         * - `S32`: substitute the result of subtracting the constant value in the last token from 32.
         *   Used by `ror` and `rol`.
         * - `DBNOP`: generate a `nop` instruction if delayed branching is enabled.
         * - `BROFFnm`: substitute `n` if delayed branching is **not** enabled; otherwise, substitute `m`. `n` and `m`
         *   are single digit numbers indicating a constant branch offset (in words).
         *
         * @param program   The current MIPS program.
         * @param template  A String containing the template for generating the basic statement.
         * @param tokenList A TokenList containing tokens from the extended instruction.
         * @return A String representing the final basic assembler statement.
         */
        @JvmStatic
        fun makeTemplateSubstitutions(program: MIPSProgram, template: String, tokenList: TokenList): String {
            var instruction = template
            var index: Int
            if (instruction.contains("DBNOP"))
                return if (Globals.settings.getBooleanSetting(CoreSettings.DELAYED_BRANCHING_ENABLED)) "nop" else ""
            // Substitute the first operand token for the template's RG1 or OP1, second for RG2 or OP2, etc.
            for (op in 1..<tokenList.size) {
                instruction = instruction.replace("RG$op", tokenList[op].value)
                instruction = instruction.replace("OP$op", tokenList[op].value)
                // Substitute the upper 16 bits of the label address, after adding the single digit constant following P
                index = instruction.indexOf("LH${op}P")
                if (index >= 0) {
                    // Label (the last operand) has already been translated to an address by the symbol table lookup
                    val label = tokenList[op].value
                    // Extract the digit following P
                    val add = instruction[index + 4].digitToInt() - 48
                    val addr = try {
                        stringToInt(label) + add
                    } catch (e: Exception) { 0 }
                    // If the address bit (15) is 1, that means the lower 16 bits will become a negative offset!
                    // To compensate for this, we need to add 1 to the high 16 bits.
                    val extra = bitValue(addr, 15)
                    instruction = instruction.replace("LH${op}P$add", ((addr shr 16) + extra).toString())
                }
                // Substitute the upper 16 bits of the label address
                // NOTE: Form LHnPm will not match here, since it is discovered and substituted above.
                if (instruction.contains("LH$op")) {
                    // Label (the last operand) has already been translated to an address by the symbol table lookup
                    val label = tokenList[op].value
                    val addr = try {
                        stringToInt(label)
                    } catch (e: Exception) { 0 }
                    val extra = bitValue(addr, 15)
                    instruction = instruction.replace("LH$op", ((addr shr 16) + extra).toString())
                }
                // Substitute the lower 16 bits of the label address, after adding the single digit that follows P
                index = instruction.indexOf("LL${op}P")
                if (index >= 0) {
                    // The label has already been translated to its address by the symbol table lookup
                    val label = tokenList[op].value
                    // Extract the digit following P
                    val add = instruction[index + 4].digitToInt() - 48
                    val addr = try {
                        stringToInt(label) + add
                    } catch (e: Exception) { 0 }
                    instruction = instruction.replace("LL${op}P$add", addr.signExtend().toString())
                }
                // Substitute the lower 16 bits of the label address.
                // NOTE: Form LLnPm will not match here, since it is discovered and substituted above.
                index = instruction.indexOf("LL$op")
                if (index >= 0) {
                    // The label has already been translated to its address by the symbol table lookup
                    val label = tokenList[op].value
                    val addr = try {
                        stringToInt(label)
                    } catch (e: Exception) { 0 }
                    instruction = if (instruction.length > index + 3 && instruction[index + 3] == 'U') {
                        instruction.replace("LL${op}U", (addr and 0xFFFF).toString())
                    } else {
                        instruction.replace("LL$op", addr.signExtend().toString())
                    }
                }
                // Substitute the upper 16 bits of the value after adding any single digit.
                // Fixes bug for `ble` and `bgt` instructions that don't adjust for the address bit being 1.
                index = instruction.indexOf("VHL${op}P")
                if (index >= 0) {
                    val value = tokenList[op].value
                    // The amount to add (1, 2, 3, or 4)
                    val add = instruction[index + 5].digitToInt() - '0'.digitToInt()
                    val newValue = try {
                        stringToInt(value) + add
                    } catch (e: Exception) { 0 }
                    instruction = instruction.replace("VHL${op}P$add", (newValue shr 16).toString())
                }
                // Substitute the upper 16 bits of the value after adding any single digit, then adjusting as necessary
                // if the resulting address bit is 1.
                index = instruction.indexOf("VH${op}P")
                if (index >= 0) {
                    val value = tokenList[op].value
                    val add = instruction[index + 4].digitToInt() - '0'.digitToInt()
                    val newValue = try {
                        stringToInt(value) + add
                    } catch (e: Exception) { 0 }
                    // If the address bit is 1, then the lower 16 bits will become a negative offset!
                    // To compensate for this, we need to add 1 to the high 16 bits.
                    val extra = bitValue(newValue, 15)
                    instruction = instruction.replace("VH${op}P$add", ((newValue shr 16) + extra).toString())
                }
                // Substitute the upper 16 bits of the value, adjusting as necessary.
                // NOTE: Form VHnPm will not match here; it is already substituted by the code above.
                if (instruction.contains("VH$op")) {
                    val value = tokenList[op].value
                    val newValue = try {
                        stringToInt(value)
                    } catch (e: Exception) { 0 }
                    // If the address bit is 1, then the lower 16 bits will become a negative offset!
                    // To compensate for this, we need to add 1 to the high 16 bits.
                    val extra = bitValue(newValue, 15)
                    instruction = instruction.replace("VH$op", ((newValue shr 16) + extra).toString())
                }
                // Substitute the lower 16 bits of the value after adding the specified amount (1, 2, 3, or 4)
                index = instruction.indexOf("VL${op}P")
                if (index >= 0) {
                    val value = tokenList[op].value
                    val add = instruction[index + 4].digitToInt() - '0'.digitToInt()
                    val newValue = try {
                        stringToInt(value) + add
                    } catch (e: Exception) { 0 }
                    instruction = if (instruction.length > index + 5 && instruction[index + 5] == 'U') {
                        instruction.replace("VL${op}P${add}U", (newValue and 0xFFFF).toString())
                    } else {
                        instruction.replace("VL${op}P$add", (newValue shr 16 shl 16).toString())
                    }
                }
                // Substitute the lower 16 bits of the value.
                // NOTE: Form VLnPm is already handled by the code above.
                index = instruction.indexOf("VL$op")
                if (index >= 0) {
                    val value = tokenList[op].value
                    val newValue = try {
                        stringToInt(value)
                    } catch (e: Exception) { 0 }
                    instruction = if (instruction.length > index + 3 && instruction[index + 3] == 'U') {
                        instruction.replace("VL${op}U", (newValue and 0xFFFF).toString())
                    } else {
                        instruction.replace("VL$op", newValue.signExtend().toString())
                    }
                }
                // Substitute the upper 16 bits of the 32-bit value.
                if (instruction.contains("VHL$op")) {
                    // The value has to be the second operand token.
                    val value = tokenList[op].value
                    val newValue = try {
                        stringToInt(value)
                    } catch (e: Exception) { 0 }
                    instruction = instruction.replace("VHL$op", (newValue shr 16).toString())
                }
            }
            // Substitute the upper 16 bits of the label address for `la`
            if (instruction.contains("LHL")) {
                // The label has already been translated to an address by the symbol table lookup
                val label = tokenList[2].value
                val addr = try {
                    stringToInt(label)
                } catch (e: Exception) { 0 }
                instruction = instruction.replace("LHL", (addr shr 16).toString())
            }
            // Substitute the upper 16 bits of the label address after adding the digit that follows "P" and adding the
            // immediate value (e.g., `here + 44($s0)`) The address will be resolved using addition, so we need to add 1
            // to the upper half if the address bit is 1.
            index = instruction.indexOf("LHPAP")
            if (index >= 0) {
                // The label has already been translated to an address by the symbol table lookup
                val label = tokenList[2].value
                val addend = tokenList[4].value
                val add = instruction[index + 5].digitToInt() - 48
                val addr = try {
                    stringToInt(label) + stringToInt(addend) + add
                } catch (e: Exception) { 0 }
                // If the address bit is 1, that means the lower 16 bits will become a negative offset!
                // To compensate for this, we need to add 1 to the high 16 bits.
                val extra = bitValue(addr, 15)
                instruction = instruction.replace("LHPAP$add", ((addr shr 16) + extra).toString())
            }
            // Substitute the upper 16 bits of the label address after adding a constant (e.g., `here + 4($s0)`)
            // The address will be resolved using addition, so we need to add 1 to the upper half if the address bit is 1
            // NOTE: Form LHPAPm is recognized and substituted by the previous code.
            if (instruction.contains("LHPA")) {
                // The label has already been translated to an address by the symbol table lookup
                val label = tokenList[2].value
                val addend = tokenList[4].value
                val addr = try {
                    stringToInt(label) + stringToInt(addend)
                } catch (e: Exception) { 0 }
                // If the address bit is 1, then the lower 16 bits will become a negative offset!
                // To compensate for this, we need to add 1 to the high 16 bits.
                val extra = bitValue(addr, 15)
                instruction = instruction.replace("LHPA", ((addr shr 16) + extra).toString())
            }
            // From this point forward, I'm not rewriting these headers to make them easier to read for now.
            // substitute upper 16 bits of label address after adding constant e.g., here+4($s0)
            // Address will be resolved using "ori", so DO NOT adjust upper 16 if bit 15 is 1.
            // This only happens in the "la" (load address) instruction.
            if (instruction.contains("LHPN")) {
                // You probably get it by now. I'm going to stop repeating these inner comments.
                val label = tokenList[2].value
                val addend = tokenList[4].value
                val addr = try {
                    stringToInt(label) + stringToInt(addend)
                } catch (e: Exception) { 0 }
                instruction = instruction.replace("LHPN", (addr shr 16).toString())
            }
            // substitute the lower 16 bits of label address after adding immediate value, e.g., here+44($s0)
            // and also adding the digit following LLPP in the spec.
            index = instruction.indexOf("LLPP")
            if (index >= 0) {
                val label = tokenList[2].value
                val addend = tokenList[4].value
                val add = instruction[index + 4].digitToInt() - 48
                val addr = try {
                    stringToInt(label) + stringToInt(addend) + add
                } catch (e: Exception) { 0 }
                instruction = instruction.replace("LLPP$add", addr.signExtend().toString())
            }
            // substitute lower 16 bits of label address after adding immediate value e.g., here+44($s0)
            // NOTE: format LLPPm is recognized and substituted by the code above
            index = instruction.indexOf("LLP")
            if (index >= 0) {
                val label = tokenList[2].value
                val addend = tokenList[4].value
                val addr = try {
                    stringToInt(label) + stringToInt(addend)
                } catch (e: Exception) { 0 }
                instruction = if (instruction.length > index + 3 && instruction[index + 3] == 'U') {
                    instruction.replace("LLPU", (addr and 0xFFFF).toString())
                } else {
                    instruction.replace("LLP", addr.signExtend().toString())
                }
            }
            // Substitute correct constant branch offset depending on whether
            // delayed branching is enabled. 2 digits follow BROFF. The first is branch offset
            // to substitute if delayed branching is DISABLED; the second is offset if ENABLED.
            index = instruction.indexOf("BROFF")
            if (index >= 0) {
                val delayedBranching = Globals.settings.getBooleanSetting(CoreSettings.DELAYED_BRANCHING_ENABLED)
                try {
                    val disabled = instruction.substring(index + 5, index + 6)
                    val enabled = instruction.substring(index + 6, index + 7)
                    instruction = instruction.replace(
                        "BROFF${disabled}${enabled}",
                        if (delayedBranching) enabled else disabled
                    )
                } catch (e: IndexOutOfBoundsException) {
                    instruction = instruction.replace("BROFF", "BAD_PSEUDO_OP_SPEC")
                }
            }
            // substitute Next higher Register for registers in token list (for "mfc1.d","mtc1.d")
            if (instruction.contains("NR")) {
                for (op in 1..<tokenList.size) {
                    val token = tokenList[op].value
                    var regNumber: Int
                    try {
                        regNumber = RegisterFile.getUserRegister(token)!!.number
                        if (regNumber >= 0)
                            instruction = instruction.replace("NR$op", "$${regNumber + 1}")
                    } catch (e: NullPointerException) {
                        regNumber = RegisterFile.getUserRegister(token)!!.number
                        if (regNumber >= 0)
                            instruction = instruction.replace("NR$op", "\$f${regNumber + 1}")
                    }
                }
            }
            // substitute result of subtracting last token from 32 (rol and ror constant rotate amount)
            if (instruction.contains("S32")) {
                val value = tokenList.last().value
                val newValue = try {
                    stringToInt(value)
                } catch (e: Exception) { 0 }
                instruction = instruction.replace("S32", (32 - newValue).toString())
            }
            // Substitute label if necessary
            if (instruction.contains("LAB")) {
                val label = tokenList.last().value
                program.getLocalSymbolTable().getLocalOrGlobalSymbolByAddress(label)?.let {
                    instruction = instruction.replaceFirst("LAB", it.name)
                }
            }
            return instruction
        }

        /**
         * Perform a string substitution.
         *
         * @param original The original string
         * @param find The string to replace
         * @param replacement The string to replace [find] with
         */
        @Deprecated(
            "Use Kotlin stdlib.",
            ReplaceWith("original.replace(find, replacement)"),
            DeprecationLevel.ERROR
        )
        @JvmStatic
        private fun substitute(original: String, find: String, replacement: String) =
            original.replace(find, replacement)

        /**
         * Perform a string substitution on the first match only.
         *
         * @param original The original string
         * @param find The string to replace
         * @param replacement The string to replace [find] with
         */
        @JvmStatic
        @Deprecated(
            "Use Kotlin stdlib.",
            ReplaceWith("original.replaceFirst(find, replacement)"),
            DeprecationLevel.ERROR
        )
        private fun substituteFirst(original: String, find: String, replacement: String) =
            original.replaceFirst(find, replacement)

        /**
         * Takes a list of basic instructions this extended instruction expands to, which is a string, and breaks it
         * out into separate instructions. They are separated by the '\n' character.
         */
        private fun buildTranslationList(translation: String?): ArrayList<String>? {
            if (translation.isNullOrEmpty()) return null
            return arrayListOf(*translation.split("\n").toTypedArray())
        }

        /**
         * Get the number of bytes that this extended instruction requires in its binary form.
         * The answer depends on how many basic instructions it expands to.
         * This may vary if the expansion includes a `nop`, depending on whether delayed branching is enabled.
         * Each instruction requires four bytes.
         * Returns the length in bytes of the corresponding binary instructions, or 0 if the list is null/empty.
         */
        private fun getInstructionLength(translationList: ArrayList<String>?): Int {
            if (translationList.isNullOrEmpty()) return 0
            // If the instruction template DBNOP, that means generate a `nop` instruction, but only
            // if delayed branching is enabled. Otherwise, generate nothing. If generating nothing,
            // then don't count the `nop` in the instruction length.
            val instructionCount = translationList.filterNot {
                it.contains("DBNOP") && !Globals.settings.getBooleanSetting(CoreSettings.DELAYED_BRANCHING_ENABLED)
            }.count()
            return 4 * instructionCount
        }
    }
}