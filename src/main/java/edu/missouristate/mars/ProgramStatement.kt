/*
 * Copyright (c) 2003-2023, Pete Sanderson and Kenneth Vollmar
 * Copyright (c) 2023-present, Nicholas Hubbard
 *
 * Originally developed by Pete Sanderson (psanderson@otterbein.edu) and Kenneth Vollmar (kenvollmar@missouristate.edu)
 * Maintained by Nicholas Hubbard (nhubbard@users.noreply.github.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of
 *    the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

@file:Suppress("MemberVisibilityCanBePrivate")

package edu.missouristate.mars

import edu.missouristate.mars.assembler.SymbolTable
import edu.missouristate.mars.assembler.TokenList
import edu.missouristate.mars.assembler.TokenTypes
import edu.missouristate.mars.mips.hardware.Coprocessor1
import edu.missouristate.mars.mips.hardware.RegisterFile
import edu.missouristate.mars.mips.instructions.BasicInstruction
import edu.missouristate.mars.mips.instructions.BasicInstructionFormat
import edu.missouristate.mars.mips.instructions.Instruction
import edu.missouristate.mars.util.Binary
import edu.missouristate.mars.venus.NumberDisplayBaseChooser

/**
 * Represents one assembly/machine statement.  This represents the "bare machine" level.
 * Pseudo-instructions have already been processed at this point, and each assembly
 * statement generated by them is one of these.
 *
 * @author Pete Sanderson and Jason Bumgarner
 * @version August 2003
 */
class ProgramStatement {
    companion object {
        private const val invalidOperator = "<INVALID>"
    }

    private val sourceMipsProgram: MIPSProgram?
    private var source: String
    private var basicAssemblyStatement: String?
    private var machineStatement: String?
    private val originalTokenList: TokenList?
    private val strippedTokenList: TokenList?
    private val basicStatementList: BasicStatementList
    private val operands: IntArray?
    private var numOperands: Int
    private val instruction: Instruction?
    private val textAddress: Int
    private var sourceLine: Int = 0
    private var binaryStatement: Int
    private val altered: Boolean

    /**
     * Constructor for ProgramStatement when there are links back to all source code and token
     * information.
     * A debugger uses these later on.
     *
     * @param sourceMipsProgram The MIPSProgram object that contains this statement
     * @param source            The corresponding MIPS source statement.
     * @param origTokenList     Complete list of Token objects (includes labels, comments, parentheses, etc)
     * @param strippedTokenList List of Token objects with all but operators and operands removed.
     * @param inst              The Instruction object for this statement's operator.
     * @param textAddress       The Text Segment address in memory where the binary machine code for this statement
     *                          is stored.
     */
    constructor(
        sourceMipsProgram: MIPSProgram, source: String, origTokenList: TokenList, strippedTokenList: TokenList,
        inst: Instruction, textAddress: Int, sourceLine: Int
    ) {
        this.sourceMipsProgram = sourceMipsProgram
        this.source = source
        this.originalTokenList = origTokenList
        this.strippedTokenList = strippedTokenList
        this.operands = IntArray(4)
        this.numOperands = 0
        this.instruction = inst
        this.textAddress = textAddress
        this.sourceLine = sourceLine
        this.basicAssemblyStatement = null
        this.basicStatementList = BasicStatementList()
        this.machineStatement = null
        this.binaryStatement = 0
        this.altered = false
    }

    /**
     * Constructor for ProgramStatement used only for writing a binary machine
     * instruction with no source code to refer back to.  Originally supported
     * only NOP instruction (all zeroes), but extended in release 4.4 to support
     * all basic instructions.  This was required for the self-modifying code
     * feature.
     *
     * @param binaryStatement The 32-bit machine code.
     * @param textAddress     The Text Segment address in memory where the binary machine code for this statement
     *                        is stored.
     */
    constructor(binaryStatement: Int, textAddress: Int) {
        sourceMipsProgram = null
        this.binaryStatement = binaryStatement
        this.textAddress = textAddress
        originalTokenList = null
        strippedTokenList = null
        source = ""
        machineStatement = null
        basicAssemblyStatement = null
        val instr = Globals.instructionSet.findByBinaryCode(binaryStatement)
        if (instr == null) {
            operands = null
            numOperands = 0
            instruction =
                if (binaryStatement == 0) Globals.instructionSet.matchOperator("nop").first() else null
        } else {
            operands = IntArray(4)
            numOperands = 0
            instruction = instr
            val operandCodes = "fst"
            val fmt = instr.operationMask
            val instrFormat = instr.instructionFormat
            var numOps = 0
            for (i in operandCodes.indices) {
                val code = operandCodes[i]
                val j = fmt.indexOf(code)
                if (j >= 0) {
                    val k0 = 31 - fmt.lastIndexOf(code)
                    val k1 = 31 - j
                    var operand = (binaryStatement shr 0) and ((1 shl (k1 - k0 + 1)) - 1)
                    if (instrFormat == BasicInstructionFormat.I_BRANCH_FORMAT && numOps == 2) {
                        operand = operand.signExtend()
                    } else if (instrFormat == BasicInstructionFormat.J_FORMAT && numOps == 0) {
                        operand = operand or (textAddress shr 2) and 0x3C000000
                    }
                    operands[numOps] = operand
                    numOps++
                }
            }
            numOperands = numOps
        }
        altered = false
        basicStatementList = buildBasicStatementListFromBinaryCode(instr, operands, numOperands)
    }

    /**
     * Given specification of BasicInstruction for this operator, build the
     * corresponding assembly statement in basic assembly format (e.g., substituting
     * register numbers for register names, replacing labels by values).
     *
     * @param errors The list of assembly errors encountered so far.  May add to it here.
     */
    fun buildBasicStatementFromBasicInstruction(errors: ErrorList) {
        var token = strippedTokenList!![0]
        var basicStatementElement = "${token.value} "
        val basic = StringBuilder(basicStatementElement)
        basicStatementList.addString(basicStatementElement)
        var tokenType: TokenTypes
        var nextTokenType: TokenTypes
        var tokenValue: String
        var registerNumber: Int
        numOperands = 0
        for (i in 1..<strippedTokenList.size) {
            token = strippedTokenList[i]
            tokenType = token.type
            tokenValue = token.value
            when (tokenType) {
                TokenTypes.REGISTER_NUMBER -> {
                    basicStatementElement = tokenValue
                    basic.append(basicStatementElement)
                    basicStatementList.addString(basicStatementElement)
                    try {
                        registerNumber = RegisterFile.getUserRegister(tokenValue)?.number ?: 0
                    } catch (e: Exception) {
                        errors.add(ErrorMessage(sourceMipsProgram, token.sourceLine, token.startPos, "Invalid register number $tokenValue."))
                        return
                    }
                    operands!![numOperands++] = registerNumber
                }
                TokenTypes.REGISTER_NAME -> {
                    registerNumber = RegisterFile.getNumber(tokenValue)
                    basicStatementElement = "$${registerNumber}"
                    basic.append(basicStatementElement)
                    basicStatementList.addString(basicStatementElement)
                    if (registerNumber < 0) {
                        errors.add(ErrorMessage(sourceMipsProgram, token.sourceLine, token.startPos, "Invalid register name $$tokenValue."))
                        return
                    }
                    operands!![numOperands++] = registerNumber
                }
                TokenTypes.FP_REGISTER_NAME -> {
                    registerNumber = Coprocessor1.getRegisterNumber(tokenValue)
                    basicStatementElement = "\$f$registerNumber"
                    basic.append(basicStatementElement)
                    basicStatementList.addString(basicStatementElement)
                    if (registerNumber < 0) {
                        errors.add(ErrorMessage(sourceMipsProgram, token.sourceLine, token.startPos, "Invalid FPU register name $tokenValue."))
                        return
                    }
                    operands!![numOperands++] = registerNumber
                }
                TokenTypes.IDENTIFIER -> {
                    var address = sourceMipsProgram?.getLocalSymbolTable()?.getAddressLocalOrGlobal(tokenValue) ?: SymbolTable.NOT_FOUND
                    if (address == SymbolTable.NOT_FOUND) {
                        errors.add(ErrorMessage(sourceMipsProgram, token.sourceLine, token.startPos, "Symbol \"$tokenValue\" not found in symbol table."))
                        return
                    }
                    var absoluteAddress = true
                    /*
                     * Notes from the original developers:
                     * - 20 Dec 2004: If basic instruction with I_BRANCH format, then translate
                     *   address from absolute to relative and shift left 2.
                     * - 14 Jun 2007: Apply delayed branching if enabled. This adds 4 bytes to the
                     *   address used to calculate branch distance in relative words.
                     * - 04 Jan 2008: Apply the delayed branching 4-byte (instruction length) addition
                     *   regardless of whether delayed branching is enabled or not. This was in response to
                     *   several people complaining about machine code not matching that from the COD3 example
                     *   on p 98-99. In that example, the branch offset reflects delayed branching because
                     *   all MIPS machines implement delayed branching. But the topic of delayed branching
                     *   is not yet introduced at that point, and instructors want to avoid the messiness
                     *   that comes along with it. Our original strategy was to do it like SPIM does, which
                     *   the June 2007 mod (shown below as commented-out assignment to address) does.
                     *   This mod must be made in conjunction with InstructionSet.java's processBranch()
                     *   method. There are some comments there as well.
                     */
                    if (instruction is BasicInstruction) {
                        val format = instruction.instructionFormat
                        if (format == BasicInstructionFormat.I_BRANCH_FORMAT) {
                            address = (address - (textAddress + Instruction.INSTRUCTION_LENGTH)) shr 2
                            absoluteAddress = false
                        }
                    }
                    basic.append(address)
                    if (absoluteAddress) {
                        basicStatementList.addAddress(address)
                    } else {
                        basicStatementList.addValue(address)
                    }
                    operands!![numOperands++] = address
                }
                TokenTypes.INTEGER_5, TokenTypes.INTEGER_16, TokenTypes.INTEGER_16U, TokenTypes.INTEGER_32 -> {
                    val tempNumeric = Binary.stringToInt(tokenValue)
                    // A large comment here about past modifications has been omitted because it talked about removing
                    // previous functionality that didn't work as expected.
                    basic.append(tempNumeric)
                    basicStatementList.addValue(tempNumeric)
                    operands!![numOperands++] = tempNumeric
                }
                else -> {
                    basicStatementElement = tokenValue
                    basic.append(basicStatementElement)
                    basicStatementList.addString(basicStatementElement)
                }
            }
            // Add separator if not at the end of the token list and neither current nor next token is a parenthesis
            if (i < strippedTokenList.size - 1) {
                nextTokenType = strippedTokenList.get(i + 1).type
                val badTypes = listOf(TokenTypes.LEFT_PAREN, TokenTypes.RIGHT_PAREN)
                if (tokenType !in badTypes && nextTokenType !in badTypes) {
                    basicStatementElement = ","
                    basic.append(basicStatementElement)
                    basicStatementList.addString(basicStatementElement)
                }
            }
        }
        basicAssemblyStatement = basic.toString()
    }

    /**
     * Given the current statement in Basic Assembly format (see above), build the
     * 32-bit binary machine code statement.
     *
     * @param errors The list of assembly errors encountered so far.  May add to it here.
     */
    fun buildMachineStatementFromBasicStatement(errors: ErrorList) {
        try {
            // Mask indicates the bit position for 'f'irst, 's'econd, and 't'hird operand
            machineStatement = (instruction as BasicInstruction).operationMask
        } catch (cce: ClassCastException) {
            // This means the pseudo-instruction expansion generated another pseudo-instruction.
            // Expansion must always result in a basic instruction.
            // This is an error on the part of the pseudo-instruction author.
            errors.add(ErrorMessage(sourceMipsProgram, sourceLine, 0, "Internal error: pseudo-instruction expansion contained a pseudo-instruction!"))
            return
        }
        val format = instruction.instructionFormat
        when (format) {
            BasicInstructionFormat.J_FORMAT -> {
                if ((textAddress and -0x10000000) != (operands!![0] and -0x10000000)) {
                    // This is an attempt to jump beyond the 28-bit byte (26-bit word) address range.
                    // SPIM would flag this as a warning,
                    // but we'll flag it as an error, because MARS' text segment is not long enough for it to fit.
                    errors.add(ErrorMessage(sourceMipsProgram, sourceLine, 0, "Jump target word address beyond 26-bit range!"))
                    return
                }
                // Note the bit shift to make this a word address.
                operands[0] = operands[0] ushr 2
                insertBinaryCode(operands[0], Instruction.operandMask[0], errors)
            }
            BasicInstructionFormat.I_BRANCH_FORMAT -> {
                for (i in 0..<(numOperands - 1))
                    insertBinaryCode(operands!![i], Instruction.operandMask[i], errors)
                insertBinaryCode(operands!![numOperands - 1], Instruction.operandMask[numOperands - 1], errors)
            }
            // R_FORMAT or I_FORMAT
            else -> {
                for (i in 0..<numOperands)
                    insertBinaryCode(operands!![i], Instruction.operandMask[i], errors)
            }
        }
        binaryStatement = Binary.binaryStringToInt(machineStatement!!)
    }

    /**
     * Crude attempt at building String representation of this complex structure.
     *
     * @return A String representing the ProgramStatement.
     */
    override fun toString(): String {
        val blanks = "                               "
        return buildString {
            append("[$textAddress]")
            basicAssemblyStatement?.let {
                val firstSpace = it.indexOf(" ")
                    append(blanks, 0, 16 - length)
                    append(it, 0, firstSpace)
                    append(blanks, 0, 24 - length)
                    append(it.substring(firstSpace + 1))
            } ?: run {
                append(blanks, 0, 16 - length)
                append("0x")
                append(binaryStatement.toString(16))
            }
            append(blanks, 0, 16 - length)
            append(";  ")
            operands?.let {
                for (i in 0..<numOperands) {
                    append(it[i].toString(16))
                    append(" ")
                }
            }
            machineStatement?.let {
                append("[${Binary.binaryStringToHexString(it)}]  ")
                val groups = listOf(0 to 6, 6 to 11, 11 to 16, 16 to 21, 21 to 26, 26 to 32)
                for ((index, group) in groups.withIndex()) {
                    val (start, end) = group
                    append(it, start, end)
                    if (index != groups.lastIndex) append("|")
                }
            }
        }
    }

    /**
     * Assigns given String to be the basic assembly statement equivalent to this source line.
     *
     * @param statement A string containing the equivalent basic assembly statement.
     */
    fun setBasicAssemblyStatement(statement: String) {
        basicAssemblyStatement = statement
    }

    /**
     * Assigns the given String to be the binary machine code
     * (32 characters, all of them either 0 or 1) equivalent to this source line.
     *
     * @param statement A String containing equivalent machine code.
     */
    fun setMachineStatement(statement: String) {
        machineStatement = statement
    }

    /**
     * Assigns the given integer to be the binary machine code equivalent to this source line.
     *
     * @param binaryCode An integer containing the equivalent binary machine code.
     */
    fun setBinaryStatement(binaryCode: Int) {
        binaryStatement = binaryCode
    }

    /**
     * Associates the MIPS source code statement with the given String value.
     * Used by the assembler when generating basic statements during macro expression of an extended statement.
     *
     * @param src A MIPS source statement.
     */
    fun setSource(src: String) {
        source = src
    }

    /**
     * @return The MIPSProgram object; can be null.
     */
    fun getSourceMipsProgram(): MIPSProgram? = sourceMipsProgram

    @Deprecated("Use lowercase version instead.", ReplaceWith("getSourceMipsProgram()"))
    fun getSourceMIPSProgram(): MIPSProgram? = getSourceMipsProgram()

    /**
     * @return The file name.
     */
    fun getSourceFile(): String = sourceMipsProgram?.getFilename() ?: ""

    /**
     * @return The MIPS source statement.
     */
    fun getSource(): String = source

    /**
     * @return The MIPS source statement line number.
     */
    fun getSourceLine(): Int = sourceLine

    /**
     * @return Produces a basic assembly statement for this MIPS source statement.
     * All numeric values are in decimal. Can be null.
     */
    fun getBasicAssemblyStatement(): String? = basicAssemblyStatement

    /**
     * Produces a printable basic assembly statement for this MIPS source statement.
     * This is generated dynamically,
     * and any addresses or values will be rendered in hex or decimal depending on the current settings.
     *
     * @return The basic assembly statement.
     */
    fun getPrintableBasicAssemblyStatement(): String = basicStatementList.toString()

    /**
     * @return The binary machine statement as a 32-character string of all ones and zeroes. Can be null.
     */
    fun getMachineStatement(): String? = machineStatement

    /**
     * @return The int version of 32-bit binary machine code.
     */
    fun getBinaryStatement(): Int = binaryStatement

    /**
     * @return The TokenList of Token objects generated from the original source.
     */
    fun getOriginalTokenList(): TokenList? = originalTokenList

    /**
     * @return The TokenList of Token objects generated by stripping the original list of all items,
     * except for the operator and operand tokens.
     */
    fun getStrippedTokenList(): TokenList? = strippedTokenList

    /**
     * @return The Instruction that matches the operator used in this statement.
     */
    fun getInstruction(): Instruction = instruction!!

    /**
     * @return address in the Text Segment of this binary machine statement.
     */
    fun getAddress(): Int = textAddress

    /**
     * @return int array of operand values (if any) required by this statement's operator.
     */
    fun getOperands(): IntArray? = operands

    /**
     * @return int array of operand values (if any) required by this statement's operator. If null, throws
     * ProcessingException.
     */
    fun getOperandsOrThrow(): IntArray =
        operands ?: throw ProcessingException(this, "Failed to get operands for instruction!")

    /**
     * @param i Operand position in the array (first operand is position 0).
     * @return Operand value at given operand array position.  If < 0 or >= numOperands, it returns -1.
     */
    fun getOperand(i: Int): Int =
        (if (i >= 0 && i < this.numOperands) operands?.getOrNull(i) else -1) ?: -1

    /**
     * Given operand (register or integer) and mask character ('f', 's', or 't'),
     * generate the correct sequence of bits and replace the mask with them.
     */
    private fun insertBinaryCode(value: Int, mask: Char, errors: ErrorList) {
        val startPos = machineStatement?.indexOf(mask) ?: -1
        val endPos = machineStatement?.lastIndexOf(mask) ?: -1
        if (startPos == -1 || endPos == -1) {
            // This should never occur.
            errors.add(ErrorMessage(sourceMipsProgram, sourceLine, 0, "Internal error: mismatch in number of operands in statement versus mask, or machineStatement is null!"))
            return
        }
        val bitString = Binary.intToBinaryString(value, endPos - startPos + 1)
        var state = machineStatement!!.substring(0, startPos) + bitString
        if (endPos < machineStatement!!.length - 1) state += machineStatement!!.substring(endPos + 1)
        machineStatement = state
    }

    /**
     * Given a model BasicInstruction and the assembled (not source) operand array for a statement,
     * this method will construct the corresponding basic instruction list. This method is
     * used by the constructor that is given only the int address and binary code. It is not
     * intended to be used when source code is available.
     */
    private fun buildBasicStatementListFromBinaryCode(
        instr: BasicInstruction?,
        operands: IntArray?,
        numOperands: Int
    ): BasicStatementList {
        val statementList = BasicStatementList()
        var tokenListCounter = 1
        if (instr == null) {
            statementList.addString(invalidOperator)
            return statementList
        } else statementList.addString("${instr.name} ")
        for (i in 0..<numOperands) {
            // Add separator if not at the end of the token list, AND neither current nor next token is a parenthesis.
            if (tokenListCounter > 1 && tokenListCounter < instr.tokenList.size) {
                val thisTokenType = instr.tokenList.get(tokenListCounter).type
                if (thisTokenType != TokenTypes.LEFT_PAREN && thisTokenType != TokenTypes.RIGHT_PAREN)
                    statementList.addString(",")
            }
            var notOperand = true
            while (notOperand && tokenListCounter < instr.tokenList.size) {
                val tokenType = instr.tokenList.get(tokenListCounter).type
                when {
                    tokenType == TokenTypes.LEFT_PAREN -> statementList.addString("(")
                    tokenType == TokenTypes.RIGHT_PAREN -> statementList.addString(")")
                    tokenType.toString().contains("REGISTER") -> {
                        val marker = if (tokenType.toString().contains("FP_REGISTER")) "\$f" else "$"
                        statementList.addString(marker + operands!![i])
                        notOperand = false
                    }
                    else -> {
                        statementList.addValue(operands!![i])
                        notOperand = false
                    }
                }
                tokenListCounter++
            }
        }
        while (tokenListCounter < instr.tokenList.size) {
            val tokenType = instr.tokenList.get(tokenListCounter).type
            when (tokenType) {
                TokenTypes.LEFT_PAREN -> statementList.addString("(")
                TokenTypes.RIGHT_PAREN -> statementList.addString(")")
                else -> {}
            }
            tokenListCounter++
        }
        return statementList
    }

    /**
     * An inside class to represent a basic statement as a list of elements.
     * Each element is either a string, an address, or a value.
     * The toString() method will return a string representation of the basic statement in which any addresses or values
     * are rendered in the current number format (e.g., decimal or hex).
     * Address operands on branch instructions are considered values instead of addresses because they are relative to
     * the PC.
     */
    private class BasicStatementList {
        private val list: ArrayList<ListElement> = arrayListOf()

        fun addString(string: String) {
            list.add(ListElement(0, string, 0))
        }

        fun addAddress(address: Int) {
            list.add(ListElement(1, null, address))
        }

        fun addValue(value: Int) {
            list.add(ListElement(2, null, value))
        }

        override fun toString(): String {
            val addressBase = if (Globals.settings.getBooleanSetting(Settings.DISPLAY_ADDRESSES_IN_HEX))
                NumberDisplayBaseChooser.HEXADECIMAL else NumberDisplayBaseChooser.DECIMAL
            val valueBase = if (Globals.settings.getBooleanSetting(Settings.DISPLAY_VALUES_IN_HEX))
                NumberDisplayBaseChooser.HEXADECIMAL else NumberDisplayBaseChooser.DECIMAL
            return buildString {
                for (element in list) {
                    when (element.type) {
                        0 -> append(element.sValue)
                        1 -> append(NumberDisplayBaseChooser.formatNumber(element.iValue, addressBase))
                        2 -> if (valueBase == NumberDisplayBaseChooser.HEXADECIMAL) {
                            append(Binary.intToHexString(element.iValue))
                        } else {
                            append(NumberDisplayBaseChooser.formatNumber(element.iValue, valueBase))
                        }
                        else -> break
                    }
                }
            }
        }

        private data class ListElement(val type: Int, val sValue: String?, val iValue: Int)
    }
}